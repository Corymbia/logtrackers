#!/usr/bin/python
import sys
import os
import socket
from subprocess import Popen, PIPE
import commands #deprecated

from datetime import datetime, date, time
from argparse import ArgumentParser
from tabulate import tabulate
import tempfile
import shutil

def has_access_key():
    try:
        return os.environ['EC2_ACCESS_KEY']!=None
    except KeyError, err:
        return False

def has_secret_key():
    try:
        return os.environ['EC2_SECRET_KEY']!=None
    except KeyError, err:
        return False

def cmd_output(args=[]):
    p = Popen(args, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    out, err = p.communicate()

    if p.returncode == 0:
        if out and len(out)>0: return out
        else: return err
    else:
        raise Exception("return code: %d" % p.returncode)

def get_euca_version():
    return cmd_output(['euca-version'])

def info(message):
    print "info: %s" % message

def warn(message):
    print "warning: %s" % message

def log_and_exit(message):
    print message;
    exit(1)

def is_ipaddr(text):
    if not text or len(text) < 7:
        return False
    tokens = text.split('.')
    if not tokens or len(tokens) != 4:
        return False
    for token in tokens:
        try:
            if int(token) < 0 or int(token) > 255:
                return False
        except Exception, err:
            return False
    return True

def get_service_address(service):
    cmdline = "euca-describe-%s" % service
    addresses = []
    output=''
    try:
        output = cmd_output([cmdline]) 
        if not output or len(output) == 0:
            log_and_exit("%s failed" % cmdline)
    except Exception, err:
            log_and_exit("%s failed" % cmdline)
    lines = output.split('\n')
    addresses = []
    for line in lines:
        tokens = line.split()
        if len(tokens) > 0:
            addresses.extend([x for x in tokens if is_ipaddr(x)])
    return addresses

def copy_log_files(address, euca_root, dest):
    log_files = [ ]
    if not os.access(dest, os.F_OK): 
        log_and_exit("Directory %s does not exist" % dest)
    cmdline = "scp %s:%s/var/log/eucalyptus/*-tracking.log* %s" % (address, euca_root, dest)
    try:
        p = Popen(cmdline.split(),stdin=None, stdout=PIPE, stderr=PIPE)
        out, err = p.communicate()
        if p.returncode != 0:
            raise Exception("return code: %d" % p.returncode)   
    except Exception, err:
        return False
    return True

def get_lines (request_id, location):
    output = None
    log_lines = {} 
    log_files = []
    if not os.access(location, os.F_OK): 
        log_and_exit("Directory %s does not exist" % location)
    if os.path.isdir(location):
        files = os.listdir(location)
        log_files.extend([location+"/"+x for x in files if os.path.isfile(location+"/"+x)])
    else:
        log_files.append(location)

    for log in log_files:
        cmdline = "grep -h %s %s" % (request_id, log)
        output = None
        try:
            output = commands.getoutput(cmdline)
        except Exception, err:
            log_and_exit("%s failed: %s" % (cmdline, err))

        if output and len(output)>0:
            log_lines[log]  = output.split('\n')

    return log_lines

log_levels = ["DEBUG","INFO","ERROR","WARN","EXTREME"]
def is_loglevel(text):
    return text in log_levels

def is_time_format(text):
    if not text or len(text) < 5:
        return False
    tokens = text.split(":")
    if len(tokens) != 3:
        return False
    for t in tokens:
        try:
            n = int(t)
            if n < 0 or n > 60:
                return False
        except Exception, err:
            return False
    return True

def is_date_format(text):
    if not text or len(text) < 5:
        return False
    tokens = text.split("-")
    if len(tokens) != 3:
        return False
    try:
        n = int(tokens[0])
        if n < 2000 or n > 2100:
            return False
        n = int(tokens[1])
        if n < 0 or n > 12:
            return False         
        n = int(tokens[2])
        if n < 0 or n > 31:
            return False
        return True
    except Exception, err:
        return False

def is_hostaddress(text):
    try:
        host = socket.gethostbyname(text)
        return host is not None 
    except Exception, err:
        try:
            addr = socket.gethostbyaddr(text)
            return addr is not None
        except Exception, err:
            return False
    return False
    
white_list = ["|"]
def parse_line (req_id, log_type, log_file, line, service_addr_map=None):
    if not line or len(line) ==0:
        return None
    tokens =  line.split()
    idx_id = -1

    # search for request id in the log line
    for i in range(0, len(tokens)):
        token = tokens[i]
        if len(token) > 0 and token.startswith("[%s"%req_id):
            idx_id = i
            break
    if idx_id < 0:
        warning("unable to find the request ID from the log line: %s" % line)
        return None

    log_msg = " ".join(tokens[idx_id+1:])
    log_location =  None
    log_level = None
    dt_time = None
    dt_date = None
    for i in reversed(range(0, idx_id))
        token = tokens[i]
        if token in white_list:
            continue
        elif not log_location: # the first text in the left of request ID is log location
            log_location = token
        elif is_loglevel(token):
            log_level = token 
        elif not dt_time and is_time_format(token):
            dt_time =token
        elif not dt_date and is_date_format(token):

    log_host = None
    log_service = None
    if log_type == 'euca' and log_file: # when log_file begins with the ip address of log's source
        tokens = log_file.split('.')
        if len(tokens) > 4 and is_host_address(".".join(tokens[0:4]))
            log_host = ".".join(tokens[0:4])
    elif log_type == 'rsyslog':
        for i in range(0, idx_id-1):
            token = tokens[i]
            if token in white_list:
                continue
            elif not log_host and is_hostaddress(token)
                log_host = socket.gethostbyname(token) #log_host should be in ip address

    if log_host:
        if log_file and log_file.endswith("cc-tracking.log"):
            log_service = "CC"
        elif log_file and log_file.endswith("nc-tracking.log"):
            log_service = "NC"
        else:
            for service in service_addr_map.keys():
                if service in ["clusters","nodes"]:
                    continue
                addresses = service_addr_map[service]
                if log_host in addresses:
                    if not log_service:
                        log_service = service
                    else:
                        log_service = "/".join([log_service, service])

class EucaLog:
    def __init__(self, request_id=None, log_dt=None, log_host=None, log_service=None, log_level=None, log_location=None, log_msg=None):
        self._request_id = request_id
        self._log_dt = log_dt
        self._log_host = log_host
        self._log_service = log_service
        self._log_level = log_level
        self._log_location = log_location
        self._log_msg = log_msg

    def message(self):
        return self._log_msg
    
    def service(self):
        return self._log_service
  
    def logtime(self):
        return self._log_dt
  
    def host(self):
        return self._log_host

    def level(self):
        return self._log_level

    def location(self):
        return self._log_location

    def __repr__(self):
        return "%s | %s | %s" % (self._log_service, self._log_dt, self._log_msg)

    def __str__(self):
        return self.__repr__()

if __name__ == "__main__":
    parser = ArgumentParser(prog='euca-req-track', description='List Eucalyptus request history')
    parser.add_argument('id', nargs=1, help='request ID to track')
    parser.add_argument('-d', '--directory', nargs=1, help='directory containing the aggregated logs')
    parser.add_argument('-t', '--log-type', nargs=1, default='euca', help='type of log files {euca, rsyslog}')
    parser.add_argument('--ssh', action="store_true", help='ssh to remote components to aggregate logs')
    args = parser.parse_args()

    if len(args.id) != 1:
        log_and_exit("Request ID must be specified")

    root_dir = os.environ['EUCALYPTUS']
    if not root_dir or len(root_dir) == 0:
        root_dir = '/'
    logdir = None
    reqid = args.id[0]
    logtype = args.log_type[0]
    services=['compute','autoscaling','loadbalancing','object-storage-gateways','clusters','euare','nodes','storage-controllers' ]
    if not (has_access_key() or has_secret_key()):
        log_and_exit("Access or secret key is not found; make sure eucarc is sourced")

    euca_version = get_euca_version()
    if not euca_version or len(euca_version) == 0:
        log_and_exit("Unable to call euca2ools; make sure euca2ools directory is in the PATH")
    addresses = {}
    for service in services:
        addresses[service] = []
        for addr in get_service_address(service):
            addresses[service].append(addr)
    if args.directory and len(args.directory) > 0:
        logdir = args.directory[0]
    elif args.ssh:
        copied=True
        tmpdir = tempfile.mkdtemp() + "/"
        for svc, addr in addresses.iteritems():
            addrtmp = tempfile.mkdtemp() + "/"
            if not copy_log_files(addr, root_dir, addrtmp):
                shutil.rmtree(addrtmp)
                copied=False
                warn("failed to copy log files from %s" %addr)
                break
            files = os.listdir(addrtmp)
            for f in files:
                os.rename("%s/%s" % (addrtmp,f), "%s/%s.%s" % (tmpdir, addr, f))
            shutil.rmtree(addrtmp)
        info("log files are copied to %s" % tmpdir)  
        logdir = tmpdir
    else:
        log_and_exit("Either directory containing aggregated logs or ssh option should be set")

    log_lines = get_lines(reqid, logdir)
    
    for log_file in log_lines.keys():
        for line in log_lines[log_file]:
            log = parse_line(reqid, log_type, log_file, line, addresses)
